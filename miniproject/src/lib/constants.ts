export const ALGORITHM_CATEGORIES = [
    {
        id: 'sorting',
        title: 'Sorting',
        description: 'Visualize how different sorting algorithms arrange elements in a specific order.',
        algorithms: ['Bubble Sort', 'Quick Sort', 'Merge Sort', 'Heap Sort', 'Selection Sort'],
    },
    {
        id: 'searching',
        title: 'Searching',
        description: 'Learn how algorithms efficiently find elements in different data structures.',
        algorithms: ['Linear Search', 'Binary Search', 'Hash-based Search', 'Jump Search', 'Exponential Search'],
    },
    {
        id: 'graphs',
        title: 'Graphs',
        description: 'Explore graph traversal and shortest path algorithms with interactive visualizations.',
        algorithms: ['BFS', 'DFS', 'Dijkstra', 'A*', 'Kruskal\'s MST'],
    },
    {
        id: 'trees',
        title: 'Trees',
        description: 'Understand tree data structures and related algorithms through visual demonstrations.',
        algorithms: ['Binary Trees', 'AVL Trees', 'Red-Black Trees', 'Heap', 'Trie'],
    },
    {
        id: 'strings',
        title: 'String Algorithms',
        description: 'Discover algorithms for pattern matching, substring search, and string manipulations.',
        algorithms: ['KMP', 'Rabin-Karp', 'Boyer-Moore', 'Regular Expressions', 'Z Algorithm'],
    },
    {
        id: 'linked-lists',
        title: 'Data Structure',
        description: 'Learn about linked list operations and manipulations with step-by-step visuals.',
        algorithms: ['Insertion', 'Deletion', 'Traversal', 'Reversal', 'Cycle Detection'],
    },
];

export const SAMPLE_QUESTIONS = [
    {
        id: 1,
        category: 'sorting',
        question: 'What is the time complexity of Bubble Sort?',
        options: ['O(n)', 'O(n log n)', 'O(n²)', 'O(1)'],
        correctAnswer: 2,
        explanation: 'Bubble Sort has a time complexity of O(n²) because it uses nested loops to compare and swap adjacent elements. For each element, it needs to compare with every other element, resulting in n * n comparisons.',
    },
    {
        id: 2,
        category: 'sorting',
        question: 'Which sorting algorithm has the best average-case time complexity?',
        options: ['Bubble Sort', 'Quick Sort', 'Selection Sort', 'Insertion Sort'],
        correctAnswer: 1,
        explanation: 'Quick Sort has an average-case time complexity of O(n log n), which is optimal for comparison-based sorting. It achieves this through its divide-and-conquer strategy and efficient partitioning.',
    },
    {
        id: 3,
        category: 'graphs',
        question: 'Which algorithm finds the shortest path in an unweighted graph?',
        options: ['DFS', 'BFS', 'Dijkstra', 'Kruskal'],
        correctAnswer: 1,
        explanation: 'Breadth-First Search (BFS) is ideal for finding shortest paths in unweighted graphs because it explores all vertices at the current depth before moving to vertices at the next depth level.',
    },
    {
        id: 4,
        category: 'trees',
        question: 'What is the maximum number of nodes at level i of a binary tree?',
        options: ['i', '2^i', '2^(i-1)', '2^(i+1)'],
        correctAnswer: 1,
        explanation: 'At each level i of a binary tree, the maximum number of nodes is 2^i. This is because each node from the previous level can have at most 2 children, leading to exponential growth.',
    },
    {
        id: 5,
        category: 'linked-lists',
        question: 'What is the time complexity of inserting at the beginning of a linked list?',
        options: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'],
        correctAnswer: 0,
        explanation: 'Inserting at the beginning of a linked list is O(1) because we only need to update the head pointer and the next pointer of the new node, regardless of the list size.',
    },
    {
        id: 6,
        category: 'sorting',
        question: 'Which of the following sorting algorithms is stable?',
        options: ['Quick Sort', 'Heap Sort', 'Merge Sort', 'Selection Sort'],
        correctAnswer: 2,
        explanation: 'Merge Sort is stable because it preserves the relative order of equal elements during merging.',
    },
    {
        id: 7,
        category: 'sorting',
        question: 'Which sorting algorithm is typically fastest for small datasets?',
        options: ['Bubble Sort', 'Insertion Sort', 'Quick Sort', 'Merge Sort'],
        correctAnswer: 1,
        explanation: 'Insertion Sort is efficient for small datasets due to low overhead and simplicity.',
    },
    {
        id: 8,
        category: 'sorting',
        question: 'What is the worst-case time complexity of Quick Sort?',
        options: ['O(n²)', 'O(n log n)', 'O(n)', 'O(log n)'],
        correctAnswer: 0,
        explanation: 'In the worst case (e.g., already sorted array with poor pivot), Quick Sort degrades to O(n²).',
    },
    {
        id: 9,
        category: 'sorting',
        question: 'Which sorting algorithm does not use recursion?',
        options: ['Merge Sort', 'Heap Sort', 'Quick Sort', 'Radix Sort'],
        correctAnswer: 1,
        explanation: 'Heap Sort is typically implemented iteratively using a heap data structure.',
    },
    {
        id: 10,
        category: 'sorting',
        question: 'What kind of sorting algorithm is Counting Sort?',
        options: ['Comparison-based', 'Non-comparison-based', 'Recursive', 'In-place'],
        correctAnswer: 1,
        explanation: 'Counting Sort is non-comparison-based; it sorts elements by counting occurrences.',
    },
    {
        id: 11,
        category: 'sorting',
        question: 'Which sorting algorithm is used in Python’s built-in `sort()`?',
        options: ['Quick Sort', 'Merge Sort', 'Heap Sort', 'Tim Sort'],
        correctAnswer: 3,
        explanation: 'Python’s `sort()` uses Tim Sort, a hybrid algorithm derived from Merge and Insertion Sort.',
    },
    {
        id: 12,
        category: 'sorting',
        question: 'Is Heap Sort an in-place sorting algorithm?',
        options: ['Yes', 'No', 'Only for max-heaps', 'Only for min-heaps'],
        correctAnswer: 0,
        explanation: 'Heap Sort sorts in place using a binary heap built in the array.',
    },
    {
        id: 13,
        category: 'sorting',
        question: 'Which sorting algorithm performs best on nearly sorted data?',
        options: ['Quick Sort', 'Insertion Sort', 'Merge Sort', 'Bubble Sort'],
        correctAnswer: 1,
        explanation: 'Insertion Sort performs very well on nearly sorted data, with time complexity approaching O(n).',
    },
    {
        id: 14,
        category: 'sorting',
        question: 'Which sorting algorithm has the best worst-case time complexity among comparison sorts?',
        options: ['Quick Sort', 'Heap Sort', 'Merge Sort', 'Bubble Sort'],
        correctAnswer: 2,
        explanation: 'Merge Sort guarantees O(n log n) in the worst case, making it optimal among comparison sorts.',
    },
    {
        id: 15,
        category: 'graphs',
        question: 'Which algorithm is used to detect cycles in a directed graph?',
        options: ['BFS', 'DFS', 'Prim’s', 'Kruskal’s'],
        correctAnswer: 1,
        explanation: 'DFS can detect cycles in a directed graph by checking for back edges in the DFS tree.',
    },
    {
        id: 16,
        category: 'graphs',
        question: 'What is the time complexity of BFS in a graph with V vertices and E edges?',
        options: ['O(V²)', 'O(E)', 'O(V + E)', 'O(V log V)'],
        correctAnswer: 2,
        explanation: 'BFS visits each vertex and edge once, giving O(V + E) complexity.',
    },
    {
        id: 17,
        category: 'graphs',
        question: 'Which algorithm is used to find the minimum spanning tree?',
        options: ['Dijkstra', 'BFS', 'Prim’s', 'Bellman-Ford'],
        correctAnswer: 2,
        explanation: 'Prim’s algorithm finds a Minimum Spanning Tree by growing a tree edge-by-edge.',
    },
    {
        id: 18,
        category: 'graphs',
        question: 'What data structure is commonly used in BFS?',
        options: ['Stack', 'Queue', 'Heap', 'Priority Queue'],
        correctAnswer: 1,
        explanation: 'BFS uses a queue to maintain the order of exploration.',
    },
    {
        id: 19,
        category: 'graphs',
        question: 'Which graph representation is more space-efficient for sparse graphs?',
        options: ['Adjacency Matrix', 'Adjacency List', 'Edge List', 'Incidence Matrix'],
        correctAnswer: 1,
        explanation: 'Adjacency List only stores existing edges, making it space-efficient for sparse graphs.',
    },
    {
        id: 20,
        category: 'graphs',
        question: 'Which algorithm works with negative weight edges?',
        options: ['Dijkstra', 'Prim’s', 'Bellman-Ford', 'Kruskal’s'],
        correctAnswer: 2,
        explanation: 'Bellman-Ford handles negative weights and detects negative cycles.',
    },
    {
        id: 21,
        category: 'graphs',
        question: 'What is a strongly connected component in a directed graph?',
        options: [
            'A node with no outgoing edges',
            'A maximal set of nodes reachable from each other',
            'A group with only incoming edges',
            'A tree within a graph'
        ],
        correctAnswer: 1,
        explanation: 'Strongly connected components are maximal subsets of nodes with paths in both directions.',
    },
    {
        id: 22,
        category: 'graphs',
        question: 'What is the result of topological sorting?',
        options: [
            'Shortest path tree',
            'Cycle detection',
            'Linear order of tasks',
            'Minimum spanning tree'
        ],
        correctAnswer: 2,
        explanation: 'Topological sort gives a linear ordering of vertices in a DAG.',
    },
    {
        id: 23,
        category: 'graphs',
        question: 'Which algorithm is greedy and used to find MST?',
        options: ['BFS', 'DFS', 'Prim’s', 'Bellman-Ford'],
        correctAnswer: 2,
        explanation: 'Prim’s algorithm is a greedy algorithm used to find the Minimum Spanning Tree.',
    },
    {
        id: 24,
        category: 'trees',
        question: 'What is the height of a tree with only one node?',
        options: ['0', '1', '-1', 'Undefined'],
        correctAnswer: 0,
        explanation: 'The height of a single-node tree is 0 because no edges exist below the root.',
    },
    {
        id: 25,
        category: 'trees',
        question: 'Which traversal order is used in Depth-First Search?',
        options: ['Level Order', 'Post-order', 'Breadth-First', 'Topological'],
        correctAnswer: 1,
        explanation: 'Post-order is one of the DFS orders where children are visited before the node.',
    },
    {
        id: 26,
        category: 'trees',
        question: 'What is an AVL tree?',
        options: ['A binary search tree', 'A self-balancing BST', 'A complete tree', 'A heap'],
        correctAnswer: 1,
        explanation: 'An AVL tree is a self-balancing BST with height balance condition of -1, 0, or 1.',
    },
    {
        id: 27,
        category: 'trees',
        question: 'What is the maximum number of nodes in a binary tree of height h?',
        options: ['2^h - 1', '2^h', '2^(h+1) - 1', 'h'],
        correctAnswer: 2,
        explanation: 'A complete binary tree has at most 2^(h+1) - 1 nodes.',
    },
    {
        id: 28,
        category: 'trees',
        question: 'Which traversal is used to get a sorted array from BST?',
        options: ['Pre-order', 'Post-order', 'In-order', 'Level-order'],
        correctAnswer: 2,
        explanation: 'In-order traversal of a BST returns nodes in ascending order.',
    },
    {
        id: 29,
        category: 'trees',
        question: 'Which data structure is used to implement a binary heap?',
        options: ['Array', 'Linked List', 'Hash Table', 'Graph'],
        correctAnswer: 0,
        explanation: 'Binary heaps are efficiently implemented using arrays due to index relationships.',
    },
    {
        id: 30,
        category: 'trees',
        question: 'What is the time complexity of searching in a balanced BST?',
        options: ['O(n)', 'O(log n)', 'O(1)', 'O(n log n)'],
        correctAnswer: 1,
        explanation: 'In a balanced BST, height is log n, making search O(log n).',
    },
    {
        id: 31,
        category: 'trees',
        question: 'What defines a complete binary tree?',
        options: ['All levels are full', 'All nodes have two children', 'All levels except last are full, and left-filled last', 'Tree has height log n'],
        correctAnswer: 2,
        explanation: 'Complete binary trees fill all levels except possibly the last, which is filled left to right.',
    },
    {
        id: 32,
        category: 'trees',
        question: 'Which tree traversal can be done without recursion or stack?',
        options: ['In-order with Morris Traversal', 'Pre-order', 'Post-order', 'Level-order'],
        correctAnswer: 0,
        explanation: 'Morris Traversal performs in-order traversal without recursion or a stack using threading.',
    },
    {
        id: 33,
        category: 'linked-lists',
        question: 'What is a circular linked list?',
        options: [
            'A list that loops back to the first node',
            'A doubly linked list',
            'A reversed list',
            'A list with random pointers'
        ],
        correctAnswer: 0,
        explanation: 'In circular linked lists, the last node points back to the head, forming a loop.',
    },
    {
        id: 34,
        category: 'linked-lists',
        question: 'Which operation is costly in a singly linked list?',
        options: ['Insert at head', 'Delete head', 'Insert at tail', 'Access by index'],
        correctAnswer: 3,
        explanation: 'Accessing by index in singly linked list requires traversal, taking O(n) time.',
    },
    {
        id: 35,
        category: 'linked-lists',
        question: 'What is the time complexity to reverse a linked list?',
        options: ['O(1)', 'O(n)', 'O(log n)', 'O(n²)'],
        correctAnswer: 1,
        explanation: 'Reversing a linked list involves re-pointing links of all nodes, which takes O(n).',
    },
    {
        id: 36,
        category: 'linked-lists',
        question: 'Which data structure is ideal for implementing stacks?',
        options: ['Array', 'Hash Map', 'Linked List', 'Queue'],
        correctAnswer: 2,
        explanation: 'Linked Lists are ideal for stacks due to efficient push/pop from head.',
    },
    {
        id: 37,
        category: 'linked-lists',
        question: 'How do you detect a cycle in a linked list?',
        options: ['Reverse the list', 'Use two pointers', 'Sort the list', 'Use a stack'],
        correctAnswer: 1,
        explanation: 'The two-pointer (slow/fast) method detects cycles efficiently.',
    },
    {
        id: 38,
        category: 'linked-lists',
        question: 'What is the advantage of doubly linked lists over singly linked lists?',
        options: ['Less memory', 'Faster access by index', 'Backward traversal', 'Simpler code'],
        correctAnswer: 2,
        explanation: 'Doubly linked lists allow traversal in both directions.',
    },
    {
        id: 39,
        category: 'linked-lists',
        question: 'What is the head in a linked list?',
        options: ['The middle node', 'Last node', 'The starting node', 'Node with max value'],
        correctAnswer: 2,
        explanation: 'The head is the first node and the entry point to the linked list.',
    },
    {
        id: 40,
        category: 'linked-lists',
        question: 'What is the tail of a singly linked list?',
        options: ['Node with no next pointer', 'Node with largest value', 'Middle node', 'Random node'],
        correctAnswer: 0,
        explanation: 'The tail is the node whose `next` pointer is null.',
    },
    {
        id: 41,
        category: 'linked-lists',
        question: 'How do you insert a node after a given node in a singly linked list?',
        options: ['Update pointers of given and new node', 'Change head', 'Shift array', 'Use a stack'],
        correctAnswer: 0,
        explanation: 'Insert by setting newNode.next = givenNode.next and then givenNode.next = newNode.',
    },
    {
        id: 42,
        category: 'searching',
        question: 'What is the time complexity of Binary Search?',
        options: ['O(n)', 'O(log n)', 'O(n log n)', 'O(1)'],
        correctAnswer: 1,
        explanation: 'Binary Search has O(log n) time complexity because it halves the search space with each comparison.',
    },
    {
        id: 43,
        category: 'searching',
        question: 'Which searching algorithm requires the data to be sorted?',
        options: ['Linear Search', 'Binary Search', 'Jump Search', 'Both Binary and Jump Search'],
        correctAnswer: 3,
        explanation: 'Both Binary Search and Jump Search require the data to be sorted to work effectively.',
    },
    {
        id: 44,
        category: 'searching',
        question: 'What is the worst-case time complexity of Linear Search?',
        options: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
        correctAnswer: 2,
        explanation: 'Linear Search has O(n) worst-case time complexity as it may need to check every element.',
    },
    {
        id: 45,
        category: 'searching',
        question: 'Which searching algorithm is best suited for linked lists?',
        options: ['Binary Search', 'Jump Search', 'Linear Search', 'Interpolation Search'],
        correctAnswer: 2,
        explanation: 'Linear Search is most suitable for linked lists due to their sequential access nature.',
    },
    {
        id: 46,
        category: 'searching',
        question: 'What is the space complexity of recursive Binary Search?',
        options: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
        correctAnswer: 1,
        explanation: 'Recursive Binary Search has O(log n) space complexity due to the call stack.',
    },
    {
        id: 47,
        category: 'strings',
        question: 'Which algorithm is most efficient for pattern matching in text?',
        options: ['Naive String Matching', 'Rabin-Karp', 'KMP Algorithm', 'Boyer-Moore'],
        correctAnswer: 3,
        explanation: 'Boyer-Moore is often the most efficient in practice due to its heuristic approaches.',
    },
    {
        id: 48,
        category: 'strings',
        question: 'What is the worst-case time complexity of the KMP algorithm?',
        options: ['O(mn)', 'O(m + n)', 'O(log n)', 'O(n²)'],
        correctAnswer: 1,
        explanation: 'KMP algorithm has O(m + n) time complexity where m is pattern length and n is text length.',
    },
    {
        id: 49,
        category: 'strings',
        question: 'Which string algorithm uses hashing for pattern matching?',
        options: ['KMP', 'Boyer-Moore', 'Rabin-Karp', 'Suffix Tree'],
        correctAnswer: 2,
        explanation: 'Rabin-Karp uses hashing to compare the pattern with text substrings.',
    },
    {
        id: 50,
        category: 'strings',
        question: 'What data structure is used in the Aho-Corasick algorithm?',
        options: ['Hash Table', 'Trie', 'Heap', 'Binary Search Tree'],
        correctAnswer: 1,
        explanation: 'Aho-Corasick uses a trie with additional failure links for multiple pattern matching.',
    },
    {
        id: 51,
        category: 'strings',
        question: 'Which algorithm finds the longest palindromic substring?',
        options: ['Manacher\'s Algorithm', 'Knuth-Morris-Pratt', 'Z Algorithm', 'Suffix Automaton'],
        correctAnswer: 0,
        explanation: 'Manacher\'s Algorithm finds the longest palindromic substring in linear time.',
    },
    {
        id: 52,
        category: 'strings',
        question: 'What is the time complexity of the naive string matching algorithm?',
        options: ['O(n)', 'O(m + n)', 'O(mn)', 'O(n²)'],
        correctAnswer: 2,
        explanation: 'The naive algorithm has O(mn) complexity where m is pattern length and n is text length.',
    },

];

export type TestResult = {
    id: string;
    userId: string;
    category: string;
    score: number;
    totalQuestions: number;
    correctAnswers: number;
    timestamp: string;
};